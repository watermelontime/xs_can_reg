// M_CAN: Main script for processing CAN XL registers and calculating bit timing parameters
import { getBits } from './func_get_bits.js';
import { sevC } from './func_get_bits.js';

// ===================================================================================
// X_CAN: Process User Register Values: parse, validate, calculate results, generate report
export function processRegsOfM_CAN(reg) {
  // Map raw addresses to register names
  mapRawRegistersToNames(reg);
  console.log('[Info] Step 2 - Mapped register values (reg object):', reg);

  // c1) Process Bit Timing registers
  procRegsPrtBitTiming(reg);
  
  // c2) Process Other PRT registers
  procRegsPrtOther(reg);
  // TODO: check new register decoding => up to now auto-generated by copilot

  console.log('[Info] Registers with data and reports, reg object:', reg);
}

// ==================================================================================
// Example Register Values for M_CAN
export function loadExampleRegisterValues() {
  const clock = 80;
  const registerString = `# M_CAN example register values
# Format to use: 0xADDR 0xVALUE
# 0xADDR is relative M_CAN address
0x000 0x32150323
0x004 0x87654321
0x008 0x00000000
0x00C 0x00801ABB
0x010 0x00000080
0x014 0x00000F0F
0x018 0x00000300
0x01C 0x3E007E1F
0x020 0x00000000
0x024 0x00000000
0x028 0xFFFF0000
0x02C 0x0000FFFF
0x040 0x00000000
0x044 0x00273008
0x048 0x00001B00
0x050 0x000000D0
0x054 0x00001001
0x058 0x00000000
0x05C 0x00000001
0x080 0x0000003F
0x084 0x000A0000
0x088 0x00010028
0x090 0x1FFFFFFF
0x094 0x00000000
0x098 0x00000000
0x09C 0x00000000
0x0A0 0x00400030
0x0A4 0x00141400
0x0A8 0x00000013
0x0AC 0x00000000
0x0B0 0x00071230
0x0B4 0x02020405
0x0B8 0x00000003
0x0BC 0x00000077
0x0C0 0x00051528
0x0C4 0x00000000
0x0C8 0x00000005
0x0CC 0x00000000
0x0D0 0x00000000
0x0D4 0x00000000
0x0D8 0x00000003
0x0DC 0x00000000
0x0E0 0x00000000
0x0E4 0x00000000
0x0F0 0x00201428
0x0F4 0x00111100
0x0F8 0x00000010`;

return {exampleRegisterValues: registerString, clockFrequency: clock};
}

// ===================================================================================
// Map raw register addresses to register names and create named register structure
function mapRawRegistersToNames(reg) {
  // Check if parse_output exists (in reg object)
  if (!reg.parse_output) {
    console.warn('[X_CAN] [Warning, mapRawRegistersToNames()] reg.parse_output not found in reg object. Skipping mapping of <raw registers> to <names>. parseUserRegisterValues(userRegText, reg) must be called before this function.');
    return;
  }
  
  // Address to register name mapping based on M_CAN specification
  const addressMap = {
    0x000: { shortName: 'CREL', longName: 'Core Release Register' },
    0x004: { shortName: 'ENDN', longName: 'Endian Register' },
    0x008: { shortName: 'CUST', longName: 'Customer Register' },
    0x00C: { shortName: 'DBTP', longName: 'Data Bit Timing & Prescaler Register' },
    0x010: { shortName: 'TEST', longName: 'Test Register' },
    0x014: { shortName: 'RWD', longName: 'RAM Watchdog' },
    0x018: { shortName: 'CCCR', longName: 'CC Control Register' },
    0x01C: { shortName: 'NBTP', longName: 'Nominal Bit Timing & Prescaler Register' },
    0x020: { shortName: 'TSCC', longName: 'Timestamp Counter Configuration' },
    0x024: { shortName: 'TSCV', longName: 'Timestamp Counter Value' },
    0x028: { shortName: 'TOCC', longName: 'Timeout Counter Configuration' },
    0x02C: { shortName: 'TOCV', longName: 'Timeout Counter Value' },
    0x040: { shortName: 'ECR', longName: 'Error Counter Register' },
    0x044: { shortName: 'PSR', longName: 'Protocol Status Register' },
    0x048: { shortName: 'TDCR', longName: 'Transmitter Delay Compensation Register' },
    0x050: { shortName: 'IR', longName: 'Interrupt Register' },
    0x054: { shortName: 'IE', longName: 'Interrupt Enable' },
    0x058: { shortName: 'ILS', longName: 'Interrupt Line Select' },
    0x05C: { shortName: 'ILE', longName: 'Interrupt Line Enable' },
    0x080: { shortName: 'GFC', longName: 'Global Filter Configuration' },
    0x084: { shortName: 'SIDFC', longName: 'Standard ID Filter Configuration' },
    0x088: { shortName: 'XIDFC', longName: 'Extended ID Filter Configuration' },
    0x090: { shortName: 'XIDAM', longName: 'Extended ID AND Mask' },
    0x094: { shortName: 'HPMS', longName: 'High Priority Message Status' },
    0x098: { shortName: 'NDAT1', longName: 'New Data 1' },
    0x09C: { shortName: 'NDAT2', longName: 'New Data 2' },
    0x0A0: { shortName: 'RXF0C', longName: 'Rx FIFO 0 Configuration' },
    0x0A4: { shortName: 'RXF0S', longName: 'Rx FIFO 0 Status' },
    0x0A8: { shortName: 'RXF0A', longName: 'Rx FIFO 0 Acknowledge' },
    0x0AC: { shortName: 'RXBC', longName: 'Rx Buffer Configuration' },
    0x0B0: { shortName: 'RXF1C', longName: 'Rx FIFO 1 Configuration' },
    0x0B4: { shortName: 'RXF1S', longName: 'Rx FIFO 1 Status' },
    0x0B8: { shortName: 'RXF1A', longName: 'Rx FIFO 1 Acknowledge' },
    0x0BC: { shortName: 'RXESC', longName: 'Rx Buffer / FIFO Element Size Configuration' },
    0x0C0: { shortName: 'TXBC', longName: 'Tx Buffer Configuration' },
    0x0C4: { shortName: 'TXFQS', longName: 'Tx FIFO/Queue Status' },
    0x0C8: { shortName: 'TXESC', longName: 'Tx Buffer Element Size Configuration' },
    0x0CC: { shortName: 'TXBRP', longName: 'Tx Buffer Request Pending' },
    0x0D0: { shortName: 'TXBAR', longName: 'Tx Buffer Add Request' },
    0x0D4: { shortName: 'TXBCR', longName: 'Tx Buffer Cancellation Request' },
    0x0D8: { shortName: 'TXBTO', longName: 'Tx Buffer Transmission Occurred' },
    0x0DC: { shortName: 'TXBCF', longName: 'Tx Buffer Cancellation Finished' },
    0x0E0: { shortName: 'TXBTIE', longName: 'Tx Buffer Transmission Interrupt Enable' },
    0x0E4: { shortName: 'TXBCIE', longName: 'Tx Buffer Cancellation Finished Interrupt Enable' },
    0x0F0: { shortName: 'TXEFC', longName: 'Tx Event FIFO Configuration' },
    0x0F4: { shortName: 'TXEFS', longName: 'Tx Event FIFO Status' },
    0x0F8: { shortName: 'TXEFA', longName: 'Tx Event FIFO Acknowledge' }
  };
  
  let mappedCount = 0;
  let unmappedCount = 0;
  
  // Process each raw register entry
  for (const rawReg of reg.raw) {
    const mapping = addressMap[rawReg.addr];
    
    if (mapping) {
      // Create named register structure
      const regName = mapping.shortName;
      reg[regName] = {
        int32: rawReg.value_int32,
        name_long: mapping.longName,
        addr: rawReg.addr
      };
      
      mappedCount++;
      
      reg.parse_output.report.push({
        severityLevel: sevC.Info, // info
        msg: `Mapped reg. address 0x${rawReg.addr.toString(16).toUpperCase().padStart(2, '0')} to ${regName} (${mapping.longName})`
      });
    } else {
      // Unknown address
      unmappedCount++;
      
      reg.parse_output.report.push({
        severityLevel: sevC.Warn, // warning
        msg: `Unknown register address: 0x${rawReg.addr.toString(16).toUpperCase().padStart(2, '0')} - register will be ignored`
      });
      reg.parse_output.hasWarnings = true;
    }
  }
  
  // Add summary message
  reg.parse_output.report.push({
    severityLevel: sevC.Info, // info
    msg: `Address mapping completed: ${mappedCount} mapped, ${unmappedCount} unknown`
  });
  
  return reg;
} // end mapRawRegistersToNames

// ===================================================================================
// Process Nominal Bit Timing Register: Extract parameters, validate ranges, calculate results, generate report
function procRegsPrtBitTiming(reg) {

  // Initialize bit timing structure in reg.general
  if (!reg.general.bt_global) {
    reg.general.bt_global = { set: {}, res: {} };
  }
  // Initialize bit timing structure in reg.general
  if (!reg.general.bt_arb) {
    reg.general.bt_arb = { set: {}, res: {} };
  }
  // Initialize bit timing structure in reg.general
  if (!reg.general.bt_fddata) {
    reg.general.bt_fddata = { set: {}, res: {} };
  }

  // Rule: only assign reg.general.* values if they get meaningful values
  //       leave values undefined, if a) according registers are not present
  //                                  b) configuration disables a feature (e.g. TMS=OFF => then do not provide PWM settings & results)

  // === CCCR: Extract parameters from register ==========================
  if ('CCCR' in reg && reg.CCCR.int32 !== undefined) {
    const regValue = reg.CCCR.int32;

    // 0. Extend existing register structure
    reg.CCCR.fields = {};
    reg.CCCR.report = []; // Initialize report array

    // 1. Decode all individual bits of CCCR register (M_CAN CC Control Register)
    reg.CCCR.fields.NISO = getBits(regValue, 15, 15);  // Non ISO Operation
    reg.CCCR.fields.TXP  = getBits(regValue, 14, 14);  // Transmit Pause
    reg.CCCR.fields.EFBI = getBits(regValue, 13, 13);  // Edge Filtering during Bus Integration
    reg.CCCR.fields.PXHD = getBits(regValue, 12, 12);  // Protocol Exception Handling Disable
    reg.CCCR.fields.WMM  = getBits(regValue, 11, 11);  // Wide Message Marker
    reg.CCCR.fields.UTSU = getBits(regValue, 10, 10);  // Use Timestamping Unit
    reg.CCCR.fields.BRSE = getBits(regValue, 9, 9);    // Bit Rate Switch Enable
    reg.CCCR.fields.FDOE = getBits(regValue, 8, 8);    // FD Operation Enable
    reg.CCCR.fields.TEST = getBits(regValue, 7, 7);    // Test Mode Enable
    reg.CCCR.fields.DAR  = getBits(regValue, 6, 6);    // Disable Automatic Retransmission
    reg.CCCR.fields.MON  = getBits(regValue, 5, 5);    // Bus Monitoring Mode
    reg.CCCR.fields.CSR  = getBits(regValue, 4, 4);    // Clock Stop Request
    reg.CCCR.fields.CSA  = getBits(regValue, 3, 3);    // Clock Stop Acknowledge
    reg.CCCR.fields.ASM  = getBits(regValue, 2, 2);    // Restricted Operation Mode
    reg.CCCR.fields.CCE  = getBits(regValue, 1, 1);    // Configuration Change Enable
    reg.CCCR.fields.INIT = getBits(regValue, 0, 0);    // Initialization
    
    // 2. Store CCCR-related bit timing settings in general structure
    reg.general.bt_global.set.fd  = (reg.CCCR.fields.FDOE === 1); // FD Operation Enable when FDOE=1
    reg.general.bt_global.set.fdbrs = (reg.CCCR.fields.BRSE === 1); // FD Bit Rate Switch Enable when BRSE=1
    reg.general.bt_global.set.es  = true;  // Error signaling always enabled in standard M_CAN
    reg.general.bt_global.set.tms = false; // No TMS (Transceiver Mode Switching) in standard M_CAN
    reg.general.bt_global.set.xl  = false; // No XL support in standard M_CAN

    // 3. Generate human-readable register report
    reg.CCCR.report.push({
        severityLevel: sevC.Info, // info
        msg: `CCCR: ${reg.CCCR.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
             `[NISO] Non ISO Operation                     = ${reg.CCCR.fields.NISO}\n` +
             `[TXP ] Transmit Pause                        = ${reg.CCCR.fields.TXP}\n` +
             `[EFBI] Edge Filtering during Bus Integration = ${reg.CCCR.fields.EFBI}\n` +
             `[PXHD] Protocol Exception Handling Disable   = ${reg.CCCR.fields.PXHD}\n` +
             `[WMM ] Wide Message Marker                   = ${reg.CCCR.fields.WMM} (0: 8 bit MM, 1: 16 bit MM)\n` +
             `[UTSU] Use Timestamping Unit (TSU)           = ${reg.CCCR.fields.UTSU} (0: internal, 1: use TSU)\n` +
             `[BRSE] Bit Rate Switch Enable                = ${reg.CCCR.fields.BRSE}\n` +
             `[FDOE] FD Operation Enable                   = ${reg.CCCR.fields.FDOE}\n` +
             `[TEST] Test Mode Enable                      = ${reg.CCCR.fields.TEST}\n` +
             `[DAR ] Disable Automatic Retransmission      = ${reg.CCCR.fields.DAR}\n` +
             `[MON ] Bus Monitoring Mode                   = ${reg.CCCR.fields.MON}\n` +
             `[CSR ] Clock Stop Request                    = ${reg.CCCR.fields.CSR}\n` +
             `[CSA ] Clock Stop Acknowledge                = ${reg.CCCR.fields.CSA}\n` +
             `[ASM ] Restricted Operation Mode             = ${reg.CCCR.fields.ASM}\n` +
             `[CCE ] Configuration Change Enable           = ${reg.CCCR.fields.CCE}\n` +
             `[INIT] Initialization                        = ${reg.CCCR.fields.INIT}`
    });

    // Check: FDOE and BRSE should both be set for FD operation
    if (reg.CCCR.fields.FDOE === 1 && reg.CCCR.fields.BRSE === 0) {
      reg.CCCR.report.push({
        severityLevel: sevC.Info,
        highlight: true,
        msg: `CCCR: FDOE is set but BRSE is not set. For full CAN FD operation, both FDOE and BRSE should be enabled.`
      });
    }

    // Check: Configuration should not be in initialization mode during normal operation
    if (reg.CCCR.fields.INIT === 1 || reg.CCCR.fields.CCE === 1) {
      reg.CCCR.report.push({
        severityLevel: sevC.Warn,
        msg: `CCCR: M_CAN is not started (no RX/TX possible): (INIT=1) or (CCE=1).`
      });
    }

    // Check: Test mode indication
    if (reg.CCCR.fields.TEST === 1) {
      reg.CCCR.report.push({
        severityLevel: sevC.Warn,
        msg: `CCCR: Test Mode is enabled (TEST=1). This should only be used for testing purposes.`
      });
    }

    // Check: Bus monitoring mode indication
    if (reg.CCCR.fields.MON === 1) {
      reg.CCCR.report.push({
        severityLevel: sevC.Warn,
        msg: `CCCR: Bus Monitoring Mode is active (MON=1). Controller will not transmit on TX pin at all, also no ACK or Error Frames.`
      });
    }

    // Check: Restricted operation mode
    if (reg.CCCR.fields.ASM === 1) {
      reg.CCCR.report.push({
        severityLevel: sevC.Warn,
        msg: `CCCR: Restricted Operation Mode is active (ASM=1). Controller will not transmit frames, but it will transmit an ACK on successful reception.`
      });
    }
  } // CCCR

  // === NBTP: Extract parameters from register ==========================
  if ('NBTP' in reg && reg.NBTP.int32 !== undefined) {
    const regValue = reg.NBTP.int32;

    // 0. Extend existing register structure
    reg.NBTP.fields = {};
    reg.NBTP.report = []; // Initialize report array

    // 1. Decode all individual bits of NBTP register (M_CAN specification)
    reg.NBTP.fields.NSJW   = getBits(regValue, 31, 25) + 1; // Nominal Synchronization Jump Width (8 bits)
    reg.NBTP.fields.NBRP   = getBits(regValue, 24, 16) + 1; // Nominal Bit Rate Prescaler (7 bits)
    reg.NBTP.fields.NTSEG1 = getBits(regValue, 15, 8) + 1;  // Nominal Time Segment 1 (9 bits)
    reg.NBTP.fields.NTSEG2 = getBits(regValue, 7, 0) + 1;   // Nominal Time Segment 2 (8 bits)

    // 2. Store NBTP bit timing settings in general structure
    reg.general.bt_arb.set.brp = reg.NBTP.fields.NBRP;
    reg.general.bt_arb.set.prop_and_phaseseg1 = reg.NBTP.fields.NTSEG1;
    reg.general.bt_arb.set.phaseseg2 = reg.NBTP.fields.NTSEG2;
    reg.general.bt_arb.set.sjw = reg.NBTP.fields.NSJW;

    // 3. Generate human-readable register report
    reg.NBTP.report.push({
        severityLevel: sevC.Info, // info
        msg: `NBTP: ${reg.NBTP.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
             `[NSJW  ] Nominal Synchronization JW = ${reg.NBTP.fields.NSJW} (range: 1-128)\n` +
             `[NBRP  ] Nominal Bit Rate Prescaler = ${reg.NBTP.fields.NBRP} (range: 1-128)\n` +
             `[NTSEG1] Nominal Time Segment 1     = ${reg.NBTP.fields.NTSEG1} (range: 1-256)\n` +
             `[NTSEG2] Nominal Time Segment 2     = ${reg.NBTP.fields.NTSEG2} (range: 1-128)`
    });

    // Validate bit field ranges according to M_CAN specification
    if (reg.NBTP.fields.NBRP < 1 || reg.NBTP.fields.NBRP > 128) {
      reg.NBTP.report.push({
        severityLevel: sevC.Error, // error
        msg: `NBTP: NBRP value ${reg.NBTP.fields.NBRP} is out of valid range (1-128)`
      });
    }

    if (reg.NBTP.fields.NTSEG1 < 1 || reg.NBTP.fields.NTSEG1 > 256) {
      reg.NBTP.report.push({
        severityLevel: sevC.Error, // error
        msg: `NBTP: NTSEG1 value ${reg.NBTP.fields.NTSEG1} is out of valid range (1-256)`
      });
    }

    if (reg.NBTP.fields.NTSEG2 < 1 || reg.NBTP.fields.NTSEG2 > 128) {
      reg.NBTP.report.push({
        severityLevel: sevC.Error, // error
        msg: `NBTP: NTSEG2 value ${reg.NBTP.fields.NTSEG2} is out of valid range (2-128)`
      });
    }

    if (reg.NBTP.fields.NSJW < 1 || reg.NBTP.fields.NSJW > 128) {
      reg.NBTP.report.push({
        severityLevel: sevC.Error, // error
        msg: `NBTP: NSJW value ${reg.NBTP.fields.NSJW} is out of valid range (1-128)`
      });
    }

    // 4. Calculate arbitration phase results and store in general structure
    reg.general.bt_arb.res.tq_len = reg.general.clk_period * reg.general.bt_arb.set.brp;
    reg.general.bt_arb.res.tq_per_bit = 1 + reg.general.bt_arb.set.prop_and_phaseseg1 + reg.general.bt_arb.set.phaseseg2;
    reg.general.bt_arb.res.bitrate = reg.general.clk_freq / (reg.general.bt_arb.set.brp * reg.general.bt_arb.res.tq_per_bit);
    reg.general.bt_arb.res.bit_length = 1000 / reg.general.bt_arb.res.bitrate;
    reg.general.bt_arb.res.sp = 100 - 100 * reg.general.bt_arb.set.phaseseg2 / reg.general.bt_arb.res.tq_per_bit;
    
    // 5. Generate Report about settings
    reg.NBTP.report.push({
        severityLevel: sevC.InfoCalc, // infoCalculated
        msg: `Nominal Bitrate (Arbitration Phase)\n` +
             `Bitrate    = ${reg.general.bt_arb.res.bitrate} Mbit/s\n` +
             `Bit Length = ${reg.general.bt_arb.res.bit_length} ns\n` +
             `TQ per Bit = ${reg.general.bt_arb.res.tq_per_bit}\n` +
             `TQ Length  = ${reg.general.bt_arb.res.tq_len} ns\n` +
             `SP         = ${reg.general.bt_arb.res.sp} %`
    });

    // Check: check for SJW <= min(PhaseSeg1, PhaseSeg2)?
    if (reg.general.bt_arb.set.sjw > reg.general.bt_arb.set.phaseseg2) {
      reg.NBTP.report.push({
        severityLevel: sevC.Error, // error
        msg: `NBTP: SJW (${reg.general.bt_arb.set.sjw}) > PhaseSeg2 (${reg.general.bt_arb.set.phaseseg2}). ISO 11898-1 requires SJW <= PhaseSeg2.`
      });
    }

    // Check: check for PhaseSeg2 >= 2
    if (reg.general.bt_arb.set.phaseseg2 < 2) {
      reg.NBTP.report.push({
        severityLevel: sevC.Error, // error
        msg: `NBTP: PhaseSeg2 (${reg.general.bt_arb.set.phaseseg2}) < 2. ISO 11898-1 requires a value >= 2.`
      });
    }

    // Check: SJW choosen as large as possible?
    if (reg.general.bt_arb.set.sjw < reg.general.bt_arb.set.phaseseg2) {
      reg.NBTP.report.push({
        severityLevel: sevC.Warn, // warning
        msg: `NBTP: SJW (${reg.general.bt_arb.set.sjw}) < PhaseSeg2 (${reg.general.bt_arb.set.phaseseg2}). It is recommended to use SJW=PhaseSeg2.`
      });
    }

    // Check: Number of TQ large enough?
    if (reg.general.bt_arb.res.tq_per_bit < 8) {
      reg.NBTP.report.push({
        severityLevel: sevC.Warn, // warning
        msg: `NBTP: Number of TQ/Bit is small. If possible, increase the TQ/Bit by reducing NBRP or increasing the CAN Clock Freq.`
      });
    }
  } // end if NBTP

  // === TDCR: Extract parameters from register ==========================
  if ('TDCR' in reg && reg.TDCR.int32 !== undefined) {
    const regValue = reg.TDCR.int32;

    // 0. Extend existing register structure
    reg.TDCR.fields = {};
    reg.TDCR.report = []; // Initialize report array

    // 1. Decode all individual bits of TDCR register (M_CAN specification)
    // See Bosch M_CAN User's Manual v3.3.1, Page 19
    reg.TDCR.fields.TDCF = getBits(regValue, 6, 0);    // Transmitter Delay Compensation Filter Window Length (7 bits)
    reg.TDCR.fields.TDCO = getBits(regValue, 14, 8);   // Transmitter Delay Compensation SSP Offset (7 bits)

    // only exclude processing register, if it is clear that a) FD operation is disabled OR b) BRS is disabled
    if (reg.general.bt_global.set.fd !== undefined && reg.general.bt_global.set.fd === false ||
        reg.general.bt_global.set.fdbrs !== undefined && reg.general.bt_global.set.fdbrs === false) {
      // 3. Generate human-readable register report
      reg.TDCR.report.push({
        severityLevel: sevC.Warn, // warning
        msg: `TDCR: ${reg.TDCR.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
             `FD Operation wir BRS is disabled: a) CCCR.FDOE=0 OR b) CCCR.BRSE=0 OR c) CCCR register not present`
      });

    } else {
      // 2. Store DBTP bit timing settings in general structure
      reg.general.bt_fddata.set.ssp_offset = reg.TDCR.fields.TDCO;

      // 3. Generate human-readable register report
      reg.TDCR.report.push({
        severityLevel: sevC.Info, // info
        msg: `TDCR: ${reg.TDCR.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
             `[TDCF] TDC Filter Window Length = ${reg.TDCR.fields.TDCF}\n` +
             `[TDCO] TDC SSP Offset           = ${reg.TDCR.fields.TDCO}`
      });

    }
  } // end if TDCR

  // === DBTP: Extract parameters from register ==========================
  if ('DBTP' in reg && reg.DBTP.int32 !== undefined) {
    const regValue = reg.DBTP.int32;

    // 0. Extend existing register structure
    reg.DBTP.fields = {};
    reg.DBTP.report = []; // Initialize report array

    // 1. Decode all individual bits of DBTP register (M_CAN specification)
    reg.DBTP.fields.TDC    = getBits(regValue, 23, 23);     // Transmitter Delay Compensation (1 bit)
    reg.DBTP.fields.DBRP   = getBits(regValue, 20, 16) + 1; // Data Bit Rate Prescaler (5 bits)
    reg.DBTP.fields.DTSEG1 = getBits(regValue, 12, 8) + 1;  // Data Time Segment 1 (5 bits)
    reg.DBTP.fields.DTSEG2 = getBits(regValue, 7, 4) + 1;   // Data Time Segment 2 (4 bits)
    reg.DBTP.fields.DSJW   = getBits(regValue, 3, 0) + 1;   // Data Synchronization Jump Width (4 bits)

    // different output based on FD enabled yes/no
    if (reg.general.bt_global.set.fd !== undefined && reg.general.bt_global.set.fd === false ||
        reg.general.bt_global.set.fdbrs !== undefined && reg.general.bt_global.set.fdbrs === false) {
      // 3. Generate human-readable register report
      reg.DBTP.report.push({
        severityLevel: sevC.Warn, // warning
        msg: `DBTP: ${reg.DBTP.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
             `FD Operation is disabled: a) CCCR.FDOE=0 OR b) CCCR.BRSE=0 OR c) CCCR register not present`
      });

    } else { // FD enabled (or CCCR register not present)
      // 2. Store DBTP bit timing settings in general structure
      reg.general.bt_global.set.tdc = (reg.DBTP.fields.TDC === 1); // TDC enabled when TDC=1
      reg.general.bt_fddata.set.prop_and_phaseseg1 = reg.DBTP.fields.DTSEG1;
      reg.general.bt_fddata.set.phaseseg2 = reg.DBTP.fields.DTSEG2;
      reg.general.bt_fddata.set.sjw = reg.DBTP.fields.DSJW;
      // set brp (M_CAN uses separate data phase prescaler)
      reg.general.bt_fddata.set.brp = reg.DBTP.fields.DBRP;
      
      // 3. Generate human-readable register report
      reg.DBTP.report.push({
          severityLevel: sevC.Info, // info
          msg: `DBTP: ${reg.DBTP.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
               `[TDC   ] Transmitter Delay Compensation = ${reg.DBTP.fields.TDC}\n` +
               `[DBRP  ] Data Bit Rate Prescaler        = ${reg.DBTP.fields.DBRP} (range: 1-32)\n` +
               `[DTSEG1] Data Time Segment 1            = ${reg.DBTP.fields.DTSEG1} (range: 1-32)\n` +
               `[DTSEG2] Data Time Segment 2            = ${reg.DBTP.fields.DTSEG2} (range: 1-16)\n` +
               `[DSJW  ] Data Synchronization JW        = ${reg.DBTP.fields.DSJW} (range: 1-16)`
      });

      // 4. Calculate FD data phase results and store in general structure
      reg.general.bt_fddata.res.tq_len = reg.general.clk_period * reg.general.bt_fddata.set.brp;
      reg.general.bt_fddata.res.tq_per_bit = 1 + reg.general.bt_fddata.set.prop_and_phaseseg1 + reg.general.bt_fddata.set.phaseseg2;
      reg.general.bt_fddata.res.bitrate = reg.general.clk_freq / (reg.general.bt_fddata.set.brp * reg.general.bt_fddata.res.tq_per_bit);
      reg.general.bt_fddata.res.bit_length = 1000 / reg.general.bt_fddata.res.bitrate;
      reg.general.bt_fddata.res.sp = 100 - 100 * reg.general.bt_fddata.set.phaseseg2 / reg.general.bt_fddata.res.tq_per_bit;
      // Calculate SSP (Secondary Sample Point) if TDC is enabled
      if (reg.general.bt_global.set.tdc === true &&
          reg.general.bt_fddata.set.ssp_offset !== undefined) {
        reg.general.bt_fddata.res.ssp = 100*reg.general.bt_fddata.set.ssp_offset/reg.general.bt_fddata.res.tq_per_bit;
      } 

      // 5. Generate Report about settings
      reg.DBTP.report.push({
          severityLevel: sevC.InfoCalc, // infoCalculated
          msg: `CAN FD Data Phase Bitrate\n` +
               `Bitrate    = ${reg.general.bt_fddata.res.bitrate} Mbit/s\n` +
               `Bit Length = ${reg.general.bt_fddata.res.bit_length} ns\n` +
               `TQ per Bit = ${reg.general.bt_fddata.res.tq_per_bit}\n` +
               `TQ Length  = ${reg.general.bt_fddata.res.tq_len} ns\n` +
               `SP         = ${reg.general.bt_fddata.res.sp} %\n` +
               `SSP        = ${reg.general.bt_fddata.res.ssp} %`
      });

      // Check: CAN Clock Frequency as recommended in CiA 601-3?
      if ((reg.general.clk_freq != 160) && (reg.general.clk_freq != 80) && (reg.general.clk_freq != 40) && (reg.general.clk_freq != 20)) {
        reg.DBTP.report.push({
          severityLevel: sevC.Warn, // warning
          msg: `CAN FD: Recommended CAN Clock Frequency is 20, 40, 80 MHz and multiples (see CiA 601-3). Current value is ${reg.general.clk_freq} MHz.`
        });
      }

      // Check: check for SJW <= min(PhaseSeg1, PhaseSeg2)?
      if (reg.general.bt_fddata.set.sjw > reg.general.bt_fddata.set.phaseseg2) {
        reg.DBTP.report.push({
          severityLevel: sevC.Error, // error
          msg: `DBTP: SJW (${reg.general.bt_fddata.set.sjw}) > PhaseSeg2 (${reg.general.bt_fddata.set.phaseseg2}). ISO 11898-1 requires SJW <= PhaseSeg2.`
        });
      }

      // Check: check for PhaseSeg2 >= 2
      if (reg.general.bt_fddata.set.phaseseg2 < 2) {
        reg.DBTP.report.push({
          severityLevel: sevC.Error, // error
          msg: `DBTP: PhaseSeg2 (${reg.general.bt_fddata.set.phaseseg2}) < 2. ISO 11898-1 requires a value >= 2.`
        });
      }

      // Check: SJW choosen as large as possible?
      if (reg.general.bt_fddata.set.sjw < reg.general.bt_fddata.set.phaseseg2) {
        reg.DBTP.report.push({
          severityLevel: sevC.Warn, // warning
          msg: `DBTP: SJW (${reg.general.bt_fddata.set.sjw}) < PhaseSeg2 (${reg.general.bt_fddata.set.phaseseg2}). It is recommended to use SJW=PhaseSeg2.`
        });
      }

      // Check: Number of TQ large enough?
      if (reg.general.bt_fddata.res.tq_per_bit < 8) {
        reg.DBTP.report.push({
          severityLevel: sevC.Warn, // warning
          msg: `DBTP: Number of TQ/Bit is small (<8). If possible, increase the TQ/Bit by reducing DBRP or increasing the CAN Clock Freq.`
        });
      }

      // Check if BRP Data > 1
      if (reg.general.bt_fddata.set.brp > 1) {
        reg.DBTP.report.push({
          severityLevel: sevC.Warn, // warning
          msg: `DBTP: BRP (${reg.general.bt_fddata.set.brp}) > 1. A BRP > 1 may reduce robustness. Try using BRP=1.`
        });
      }

    } // end if FDOE=1
  } // end if DBTP

} // end procRegsPrtBitTiming

// ===================================================================================
// Process Other PRT Registers: Extract parameters, validate ranges, generate report
function procRegsPrtOther(reg) {

  // === CREL: PRT Release Identification Register =========================
  if ('CREL' in reg && reg.CREL.int32 !== undefined) {
    const regValue = reg.CREL.int32;

    // 0. Extend existing register structure
    reg.CREL.fields = {};
    reg.CREL.report = []; // Initialize report array

    // 1. Decode all individual bits
    reg.CREL.fields.REL = getBits(regValue, 31, 28); // Release
    reg.CREL.fields.STEP = getBits(regValue, 27, 24); // Step
    reg.CREL.fields.SUBSTEP = getBits(regValue, 23, 20); // Substep
    reg.CREL.fields.YEAR = getBits(regValue, 19, 16); // Year
    reg.CREL.fields.MON = getBits(regValue, 15, 8); // Month
    reg.CREL.fields.DAY = getBits(regValue, 7, 0); // Day
    
    // 2. Generate human-readable register report
    reg.CREL.report.push({
      severityLevel: sevC.Info, // info
      msg: `CREL: ${reg.CREL.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[REL    ] Release = 0x${reg.CREL.fields.REL.toString(16).toUpperCase()}\n` +
           `[STEP   ] Step    = 0x${reg.CREL.fields.STEP.toString(16).toUpperCase()}\n` +
           `[SUBSTEP] Substep = 0x${reg.CREL.fields.SUBSTEP.toString(16).toUpperCase()}\n` +
           `[YEAR   ] Year    = 0x${reg.CREL.fields.YEAR.toString(16).toUpperCase()}\n` +
           `[MON    ] Month   = 0x${reg.CREL.fields.MON.toString(16).toUpperCase().padStart(2, '0')}\n` +
           `[DAY    ] Day     = 0x${reg.CREL.fields.DAY.toString(16).toUpperCase().padStart(2, '0')}`
    });

    // Generate Version Report
    reg.CREL.report.push({
      severityLevel: sevC.Info,
      highlight: true,
      msg: `CREL: M_CAN V${reg.CREL.fields.REL.toString(16).toUpperCase()}.${reg.CREL.fields.STEP.toString(16).toUpperCase()}.${reg.CREL.fields.SUBSTEP.toString(16).toUpperCase()}, Date ${reg.CREL.fields.DAY.toString(16).toUpperCase().padStart(2, '0')}.${reg.CREL.fields.MON.toString(16).toUpperCase().padStart(2, '0')}.${reg.CREL.fields.YEAR.toString(16).toUpperCase().padStart(2, '0')}`
    });
  }

  // === ENDN: Endianness Test Register ====================================
  if ('ENDN' in reg && reg.ENDN.int32 !== undefined) {
    const regValue = reg.ENDN.int32;

    // 0. Extend existing register structure
    reg.ENDN.fields = {};
    reg.ENDN.report = []; // Initialize report array

    // 1. Decode ENDN register (simple 32-bit value)
    reg.ENDN.fields.ETV = regValue; // Endianness Test Value

    // 2. Generate human-readable register report
    if (regValue === 0x87654321) {
      reg.ENDN.report.push({
        severityLevel: sevC.Info, // info
        msg: `ENDN: ${reg.ENDN.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
             `[ETV] Endianness Test Value = 0x${regValue.toString(16).toUpperCase().padStart(8, '0')} (Correct)`
      });
    } else {
      reg.ENDN.report.push({
        severityLevel: sevC.Error, // error
        msg: `ENDN: ${reg.ENDN.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
             `[ETV] Endianness Test Value = 0x${regValue.toString(16).toUpperCase().padStart(8, '0')} (Expected: 0x87654321)`
      });
    }
  } // ENDN

  // === CUST: Customer Register ================================
  if ('CUST' in reg && reg.CUST.int32 !== undefined) {
    const regValue = reg.CUST.int32;

    // 0. Extend existing register structure
    reg.CUST.fields = {};
    reg.CUST.report = []; // Initialize report array

    // Generate human-readable register report
    reg.CUST.report.push({
      severityLevel: sevC.Info, // info
      msg: `CUST: ${reg.CUST.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})`
    });
  } // CUST

  // === TEST: Hardware Test Functions Register ========================
  if ('TEST' in reg && reg.TEST.int32 !== undefined) {
    const regValue = reg.TEST.int32;

    // 0. Extend existing register structure
    reg.TEST.fields = {};
    reg.TEST.report = []; // Initialize report array

    // 1. Decode all individual bits of TEST register
    reg.TEST.fields.SVAL  = getBits(regValue, 21, 21); // Started Valid
    reg.TEST.fields.TXBNS = getBits(regValue, 20, 16); // TX Buffer Number Started
    reg.TEST.fields.PVAL  = getBits(regValue, 13, 13); // Prepend Valid
    reg.TEST.fields.TXBNP = getBits(regValue, 12,  8); // TX Buffer Number Prepend
    reg.TEST.fields.RX    = getBits(regValue, 7, 7); // Receive Pin
    reg.TEST.fields.TX    = getBits(regValue, 6, 5); // TX Pin Control
    reg.TEST.fields.LBCK  = getBits(regValue, 4, 4); // Loop Back Mode

    // 2. Generate human-readable register report
    reg.TEST.report.push({
      severityLevel: sevC.Info, // info
      msg: `TEST: ${reg.TEST.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[SVAL ] Started Valid             = ${reg.TEST.fields.SVAL}\n` +
           `[TXBNS] TX Buffer Number Started  = ${reg.TEST.fields.TXBNS}\n` +
           `[PVAL ] Prepend Valid             = ${reg.TEST.fields.PVAL}\n` +
           `[TXBNP] TX Buffer Number Prepared = ${reg.TEST.fields.TXBNP}\n` +
           `[RX   ] RX Pin                    = ${reg.TEST.fields.RX}\n` +
           `[TX   ] TX Pin Control            = ${reg.TEST.fields.TX} (0: PRT controlled, 1: SP monitor, 2: Dominant, 3: Recessive)\n` +
           `[LBCK ] Loop Back Mode            = ${reg.TEST.fields.LBCK} (1: enabled)`
    });

    // 3. Report test mode information messages
    if (reg.TEST.fields.LBCK === 1) {
      reg.TEST.report.push({
        severityLevel: sevC.Warn,
        msg: `Loop Back Mode is active - for testing only\n` +
             `When CCCR.MON=1 it is the internal loopback (TX pin shows always recessive)\n` +
             `When CCCR.MON=0 it is the external loopback (TX pin driven by M_CAN PRT)`
      });
    }
    
    if (reg.TEST.fields.TX !== 0) {
      reg.TEST.report.push({
        severityLevel: sevC.Warn,
        msg: `Test Mode is active: TX Pin is under manual control! CAN messages cannot be transmitted.`
      });
    }
  }


  // === RWD: RAM Watchdog ================================================
  if ('RWD' in reg && reg.RWD.int32 !== undefined) {
    const regValue = reg.RWD.int32;

    // 0. Extend existing register structure
    reg.RWD.fields = {};
    reg.RWD.report = []; // Initialize report array

    // 1. Decode all individual bits of RWD register (M_CAN User Manual v3.3.1, page 10)
    reg.RWD.fields.WDV = getBits(regValue, 15, 8);  // Watchdog Value (8 bits)
    reg.RWD.fields.WDC = getBits(regValue, 7, 0);   // Watchdog Configuration (8 bits)

    // 2. Generate human-readable register report
    reg.RWD.report.push({
      severityLevel: sevC.Info, // info
      msg: `RWD: ${reg.RWD.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[WDV] Watchdog Value         = ${reg.RWD.fields.WDV} (current Watchdog counter value)\n` +
           `[WDC] Watchdog Configuration = ${reg.RWD.fields.WDC} (0: disabled, else: start value of Watchdog down-counter)`
    });

    // 3. Add warnings or info if Watchdog Value is close to Configuration
    if (reg.RWD.fields.WDC > 0) {
      reg.RWD.report.push({
        severityLevel: sevC.Info,
        highlight: true,
        msg: `RAM Watchdog is enabled. Configuration: WDC = ${reg.RWD.fields.WDC} Host Clock Cycles`
      });
    }
  }

  // === TSCC: Timestamp Counter Configuration =============================
  if ('TSCC' in reg && reg.TSCC.int32 !== undefined) {
    const regValue = reg.TSCC.int32;

    // 0. Extend existing register structure
    reg.TSCC.fields = {};
    reg.TSCC.report = []; // Initialize report array

    // 1. Decode all individual bits of TSCC register (M_CAN User Manual v3.3.1, page 14)
    reg.TSCC.fields.TCP = getBits(regValue, 19, 16) + 1; // Timestamp Counter Prescaler (4 bits)
    reg.TSCC.fields.TSS = getBits(regValue,  1,  0); // Timestamp Select (2 bits)

    // 2. Generate human-readable register report
    reg.TSCC.report.push({
      severityLevel: sevC.Info, // info
      msg: `TSCC: ${reg.TSCC.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[TCP] Timestamp Counter Prescaler = ${reg.TSCC.fields.TCP} (values 1..16)\n` +
           `[TSS] Timestamp Select            = ${reg.TSCC.fields.TSS} (0: disabled, 1: TS counter internal, 2: TS counter external, 3: disabled)`
    });
  } // TSCC

  // === TSCV: Timestamp Counter Value =========================================
  if ('TSCV' in reg && reg.TSCV.int32 !== undefined) {
    const regValue = reg.TSCV.int32;

    // 0. Extend existing register structure
    reg.TSCV.fields = {};
    reg.TSCV.report = []; // Initialize report array

    // 1. Decode all individual bits of TSCV register (M_CAN User Manual v3.3.1, page 14)
    reg.TSCV.fields.TSC = getBits(regValue, 15, 0); // Timestamp Counter Value (16 bits)

    // 2. Generate human-readable register report
    reg.TSCV.report.push({
      severityLevel: sevC.Info, // info
      msg: `TSCV: ${reg.TSCV.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[TSC] Timestamp Counter Value = ${reg.TSCV.fields.TSC} (counter width: 16 bit)`
    });
  } // TSCV

  // === TOCC: Timeout Counter Configuration ==============================
  if ('TOCC' in reg && reg.TOCC.int32 !== undefined) {
    const regValue = reg.TOCC.int32;

    // 0. Extend existing register structure
    reg.TOCC.fields = {};
    reg.TOCC.report = []; // Initialize report array

    // 1. Decode all individual bits of TOCC register (M_CAN User Manual v3.3.1, page 15)
    reg.TOCC.fields.TOP  = getBits(regValue, 31, 16); // Timeout Period (16 bits)
    reg.TOCC.fields.TOS  = getBits(regValue,  2,  1); // Timeout Select (2 bits)
    reg.TOCC.fields.ETOC = getBits(regValue,  0,  0); // Enable Timeout Counter (1 bit)

    // 2. Generate human-readable register report
    reg.TOCC.report.push({
      severityLevel: sevC.Info, // info
      msg: `TOCC: ${reg.TOCC.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[TOP ] Timeout Period         = ${reg.TOCC.fields.TOP}\n` +
           `[TOS ] Timeout Select         = ${reg.TOCC.fields.TOS} (0: continuous, 1: TX Event FIFO, 2: RX FIFO0, 3: RX FIFO1)\n` +
           `[ETOC] Enable Timeout Counter = ${reg.TOCC.fields.ETOC}`  
    });
  }

  // === TOCV: Timeout Counter Value ======================================
  if ('TOCV' in reg && reg.TOCV.int32 !== undefined) {
    const regValue = reg.TOCV.int32;

    // 0. Extend existing register structure
    reg.TOCV.fields = {};
    reg.TOCV.report = []; // Initialize report array

    // 1. Decode all individual bits of TOCV register (M_CAN User Manual v3.3.1, page 15)
    reg.TOCV.fields.TOC = getBits(regValue, 15, 0); // Timeout Counter Value (16 bits)

    // 2. Generate human-readable register report
    reg.TOCV.report.push({
      severityLevel: sevC.Info, // info
      msg: `TOCV: ${reg.TOCV.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[TOC] Timeout Counter Value = ${reg.TOCV.fields.TOC} (counter width: 16 bit)`
    });
  }

  // === ECR: Error Counter Register =======================================
  if ('ECR' in reg && reg.ECR.int32 !== undefined) {
    const regValue = reg.ECR.int32;

    // 0. Extend existing register structure
    reg.ECR.fields = {};
    reg.ECR.report = []; // Initialize report array

    // 1. Decode all individual bits of ECR register (M_CAN User Manual v3.3.1, page 16)
    reg.ECR.fields.CEL = getBits(regValue, 23, 16); // CAN Error Logging (8 bits)
    reg.ECR.fields.RP  = getBits(regValue, 15, 15); // Receive Error Passive (1 bit)
    reg.ECR.fields.REC = getBits(regValue, 14,  8); // Receive Error Counter (7 bits)
    reg.ECR.fields.TEC = getBits(regValue,  7,  0); // Transmit Error Counter (8 bits)

    // 2. Generate human-readable register report
    reg.ECR.report.push({
      severityLevel: sevC.Info, // info
      msg: `ECR: ${reg.ECR.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[CEL] CAN Error Logging      = ${reg.ECR.fields.CEL}\n` +
           `[RP ] Receive Error Passive  = ${reg.ECR.fields.RP} (1: Rec. Err Counter reached Error Passive Level of 128)\n` +
           `[REC] Receive Error Counter  = ${reg.ECR.fields.REC}\n` +
           `[TEC] Transmit Error Counter = ${reg.ECR.fields.TEC}`
    });

    // 3. Add warnings if error counters are high
    if (reg.ECR.fields.TEC > 0) {
      reg.ECR.report.push({
        severityLevel: sevC.Warn,
        msg: `Transmit Error Counter (${reg.ECR.fields.TEC}) > 0: Transmit Errors seen recently.`
      });
    }
    if (reg.ECR.fields.REC > 0) {
      reg.ECR.report.push({
        severityLevel: sevC.Warn,
        msg: `Receive Error Counter (${reg.ECR.fields.REC}) > 0. Receive Errors seen recently.`
      });
    }
    if (reg.ECR.fields.RP === 1) {
      reg.ECR.report.push({
        severityLevel: sevC.Warn,
        msg: `Receive Error Passive flag is set. CAN controller is in error passive state for receive.`
      });
    }
  }

  // === PSR: PRT Status Register =========================================
  if ('PSR' in reg && reg.PSR.int32 !== undefined) {
    const regValue = reg.PSR.int32;

    // 0. Extend existing register structure
    reg.PSR.fields = {};
    reg.PSR.report = []; // Initialize report array

    // 1. Decode all individual bits of PSR register (M_CAN User Manual v3.3.1, pages 17-18)
    reg.PSR.fields.LEC   = getBits(regValue, 2, 0);    // Last Error Code (3 bits)
    reg.PSR.fields.ACT   = getBits(regValue, 4, 3);    // Activity (2 bits)
    reg.PSR.fields.EP    = getBits(regValue, 5, 5);    // Error Passive (1 bit)
    reg.PSR.fields.EW    = getBits(regValue, 6, 6);    // Error Warning (1 bit)
    reg.PSR.fields.BO    = getBits(regValue, 7, 7);    // Bus Off (1 bit)
    reg.PSR.fields.DLEC  = getBits(regValue, 10, 8);   // Data Phase Last Error Code (3 bits)
    reg.PSR.fields.RESI  = getBits(regValue, 11, 11);  // ESI flag of last received CAN FD message (1 bit)
    reg.PSR.fields.RBRS  = getBits(regValue, 12, 12);  // BRS flag of last received CAN FD message (1 bit)
    reg.PSR.fields.RFDF  = getBits(regValue, 13, 13);  // Received a CAN FD Message(1 bit)
    reg.PSR.fields.TDCV  = getBits(regValue, 20, 16);  // Transmitter Delay Compensation Value (5 bits)

    // 2. Generate human-readable register report
    reg.PSR.report.push({
      severityLevel: sevC.Info,
      msg: `PSR: ${reg.PSR.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[LEC ] Last Error Code Arb. Phase  = ${reg.PSR.fields.LEC} (0: No Error, 1: Stuff, 2: Form, 3: Ack, 4: Bit1, 5: Bit0, 6: CRC, 7: No Change)\n` +
           `[ACT ] Activity                    = ${reg.PSR.fields.ACT} (0: Synchronizing, 1: Idle, 2: Receiver, 3: Transmitter)\n` +
           `[EP  ] Error Passive               = ${reg.PSR.fields.EP}\n` +
           `[EQ  ] Error Warning               = ${reg.PSR.fields.EW}\n` +
           `[BO  ] Bus Off                     = ${reg.PSR.fields.BO}\n` +
           `[DLEC] Last Error Code Data Phase  = ${reg.PSR.fields.DLEC} (0: No Error, 1: Stuff, 2: Form, 3: Ack, 4: Bit1, 5: Bit0, 6: CRC, 7: No Change)\n` +
           `[RESI] ESI flag of last CAN FD msg = ${reg.PSR.fields.RESI}\n` +
           `[RBRS] BRS flag of last CAN FD msg = ${reg.PSR.fields.RBRS}\n` +
           `[RFDF] Received a CAN FD Message   = ${reg.PSR.fields.RFDF}\n` +
           `[TDCV] TDC Value (=TLD+SSP_offset) = ${reg.PSR.fields.TDCV} => ${reg.PSR.fields.TDCV*reg.general.clk_period} ns`
    });

    // 3. Add status-specific warnings/errors
    if (reg.PSR.fields.BO === 1) {
      reg.PSR.report.push({
        severityLevel: sevC.Warn,
        msg: `CAN controller is in Bus Off state`
      });
    }
    if (reg.PSR.fields.EP === 1) {
      reg.PSR.report.push({
        severityLevel: sevC.Warn,
        msg: `CAN controller is in Error Passive state`
      });
    }
    if (reg.PSR.fields.LEC > 0 && reg.PSR.fields.LEC < 7) {
      reg.PSR.report.push({
        severityLevel: sevC.Warn,
        msg: `Last Error Code (Arbitration Phase) indicates a recent error: ${reg.PSR.fields.LEC}`
      });
    }
    if (reg.PSR.fields.DLEC > 0 && reg.PSR.fields.DLEC < 7) {
      reg.PSR.report.push({
        severityLevel: sevC.Warn,
        msg: `Last Error Code (Data Phase) indicates a recent error: ${reg.PSR.fields.DLEC}`
      });
    }
  } // PSR
  // TODO: Register-Addresse ausgeben bei jedem Register in der ersten Zeile.
  // TODO AB HIER: Check the decoding of the registers. It The code is written by copilot.
  // === EVNT: Event Status Flags Register ================================
  if ('EVNT' in reg && reg.EVNT.int32 !== undefined) {
    const regValue = reg.EVNT.int32;

    // 0. Extend existing register structure
    reg.EVNT.fields = {};
    reg.EVNT.report = []; // Initialize report array

    // 1. Decode all individual bits of EVNT register
    reg.EVNT.fields.RXFI = getBits(regValue, 31, 31); // RX FIFO Interrupt
    reg.EVNT.fields.TXFI = getBits(regValue, 30, 30); // TX FIFO Interrupt
    reg.EVNT.fields.TEFI = getBits(regValue, 29, 29); // TX Event FIFO Interrupt
    reg.EVNT.fields.HPMI = getBits(regValue, 28, 28); // High Priority Message Interrupt
    reg.EVNT.fields.WKUI = getBits(regValue, 27, 27); // Wake Up Interrupt
    reg.EVNT.fields.MRAF = getBits(regValue, 17, 17); // Message RAM Access Failure
    reg.EVNT.fields.TSWE = getBits(regValue, 16, 16); // Timestamp Wraparound Event
    reg.EVNT.fields.ELO = getBits(regValue, 15, 15); // Error Logging Overflow
    reg.EVNT.fields.EP = getBits(regValue, 14, 14); // Error Passive
    reg.EVNT.fields.EW = getBits(regValue, 13, 13); // Error Warning
    reg.EVNT.fields.BO = getBits(regValue, 12, 12); // Bus Off
    reg.EVNT.fields.WDI = getBits(regValue, 11, 11); // Watchdog Interrupt
    reg.EVNT.fields.PEA = getBits(regValue, 10, 10); // Protocol Error in Arbitration Phase
    reg.EVNT.fields.PED = getBits(regValue, 9, 9); // Protocol Error in Data Phase
    reg.EVNT.fields.ARA = getBits(regValue, 8, 8); // Access to Reserved Address

    // 2. Generate human-readable register report
    reg.EVNT.report.push({
      severityLevel: sevC.Info, // info
      msg: `EVNT: ${reg.EVNT.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[RXFI] RX FIFO Interrupt          = ${reg.EVNT.fields.RXFI}\n` +
           `[TXFI] TX FIFO Interrupt          = ${reg.EVNT.fields.TXFI}\n` +
           `[TEFI] TX Event FIFO Interrupt    = ${reg.EVNT.fields.TEFI}\n` +
           `[HPMI] High Priority Message Int  = ${reg.EVNT.fields.HPMI}\n` +
           `[WKUI] Wake Up Interrupt          = ${reg.EVNT.fields.WKUI}\n` +
           `[MRAF] Message RAM Access Failure = ${reg.EVNT.fields.MRAF}\n` +
           `[TSWE] Timestamp Wraparound Event = ${reg.EVNT.fields.TSWE}\n` +
           `[ELO ] Error Logging Overflow     = ${reg.EVNT.fields.ELO}\n` +
           `[EP  ] Error Passive              = ${reg.EVNT.fields.EP}\n` +
           `[EW  ] Error Warning              = ${reg.EVNT.fields.EW}\n` +
           `[BO  ] Bus Off                    = ${reg.EVNT.fields.BO}\n` +
           `[WDI ] Watchdog Interrupt         = ${reg.EVNT.fields.WDI}\n` +
           `[PEA ] Protocol Error Arbitration = ${reg.EVNT.fields.PEA}\n` +
           `[PED ] Protocol Error Data Phase  = ${reg.EVNT.fields.PED}\n` +
           `[ARA ] Access to Reserved Address = ${reg.EVNT.fields.ARA}`
    });

    // 3. Add event-specific warnings/errors
    if (reg.EVNT.fields.BO === 1) {
      reg.EVNT.report.push({
        severityLevel: sevC.Error, // error
        msg: `Bus Off condition detected - CAN controller is offline`
      });
    }
    if (reg.EVNT.fields.EP === 1) {
      reg.EVNT.report.push({
        severityLevel: sevC.Warn, // warning
        msg: `Error Passive state - high error rate detected`
      });
    }
    if (reg.EVNT.fields.EW === 1) {
      reg.EVNT.report.push({
        severityLevel: sevC.Recom, // recommendation
        msg: `Error Warning state - monitor error counters`
      });
    }
    if (reg.EVNT.fields.MRAF === 1) {
      reg.EVNT.report.push({
        severityLevel: sevC.Error, // error
        msg: `Message RAM Access Failure detected`
      });
    }
  }

  // === LOCK: Unlock Sequence Register ===================================
  if ('LOCK' in reg && reg.LOCK.int32 !== undefined) {
    const regValue = reg.LOCK.int32;

    // 0. Extend existing register structure
    reg.LOCK.fields = {};
    reg.LOCK.report = []; // Initialize report array

    // 1. Decode LOCK register
    reg.LOCK.fields.UNLOCK = regValue; // Unlock Value

    // 2. Generate human-readable register report
    reg.LOCK.report.push({
      severityLevel: sevC.Info, // info
      msg: `LOCK: ${reg.LOCK.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[UNLOCK] Unlock Value = 0x${regValue.toString(16).toUpperCase().padStart(8, '0')}`
    });
  }

  // === CTRL: Control Register ==========================================
  if ('CTRL' in reg && reg.CTRL.int32 !== undefined) {
    const regValue = reg.CTRL.int32;

    // 0. Extend existing register structure
    reg.CTRL.fields = {};
    reg.CTRL.report = []; // Initialize report array

    // 1. Decode all individual bits of CTRL register
    reg.CTRL.fields.NISO = getBits(regValue, 15, 15); // Non-ISO Operation
    reg.CTRL.fields.TXP = getBits(regValue, 14, 14); // Transmit Pause
    reg.CTRL.fields.EFBI = getBits(regValue, 13, 13); // Edge Filtering during Bus Integration
    reg.CTRL.fields.PXHD = getBits(regValue, 12, 12); // Protocol Exception Handling Disable
    reg.CTRL.fields.WMM = getBits(regValue, 11, 11); // Wide Message Marker
    reg.CTRL.fields.UTSU = getBits(regValue, 10, 10); // Use Timestamping Unit
    reg.CTRL.fields.BRSE = getBits(regValue, 9, 9); // Bit Rate Switch Enable
    reg.CTRL.fields.LOM = getBits(regValue, 8, 8); // Loop Back Mode
    reg.CTRL.fields.DAR = getBits(regValue, 7, 7); // Disable Automatic Retransmission
    reg.CTRL.fields.CCE = getBits(regValue, 6, 6); // Configuration Change Enable
    reg.CTRL.fields.TEST = getBits(regValue, 5, 5); // Test Mode Enable
    reg.CTRL.fields.MON = getBits(regValue, 4, 4); // Bus Monitoring Mode
    reg.CTRL.fields.CSR = getBits(regValue, 3, 3); // Clock Stop Request
    reg.CTRL.fields.CSA = getBits(regValue, 2, 2); // Clock Stop Acknowledge
    reg.CTRL.fields.ASM = getBits(regValue, 1, 1); // Restricted Operation Mode
    reg.CTRL.fields.INIT = getBits(regValue, 0, 0); // Initialization

    // 2. Generate human-readable register report
    reg.CTRL.report.push({
      severityLevel: sevC.Info, // info
      msg: `CTRL: ${reg.CTRL.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[NISO] Non-ISO Operation              = ${reg.CTRL.fields.NISO}\n` +
           `[TXP ] Transmit Pause                 = ${reg.CTRL.fields.TXP}\n` +
           `[EFBI] Edge Filtering Bus Integration = ${reg.CTRL.fields.EFBI}\n` +
           `[PXHD] Protocol Exception Disable     = ${reg.CTRL.fields.PXHD}\n` +
           `[WMM ] Wide Message Marker            = ${reg.CTRL.fields.WMM}\n` +
           `[UTSU] Use Timestamping Unit          = ${reg.CTRL.fields.UTSU}\n` +
           `[BRSE] Bit Rate Switch Enable         = ${reg.CTRL.fields.BRSE}\n` +
           `[LOM ] Loop Back Mode                 = ${reg.CTRL.fields.LOM}\n` +
           `[DAR ] Disable Auto Retransmission    = ${reg.CTRL.fields.DAR}\n` +
           `[CCE ] Configuration Change Enable    = ${reg.CTRL.fields.CCE}\n` +
           `[TEST] Test Mode Enable               = ${reg.CTRL.fields.TEST}\n` +
           `[MON ] Bus Monitoring Mode            = ${reg.CTRL.fields.MON}\n` +
           `[CSR ] Clock Stop Request             = ${reg.CTRL.fields.CSR}\n` +
           `[CSA ] Clock Stop Acknowledge         = ${reg.CTRL.fields.CSA}\n` +
           `[ASM ] Restricted Operation Mode      = ${reg.CTRL.fields.ASM}\n` +
           `[INIT] Initialization                 = ${reg.CTRL.fields.INIT}`
    });

    // 3. Add control-specific information
    if (reg.CTRL.fields.INIT === 1) {
      reg.CTRL.report.push({
        severityLevel: sevC.Recom, // recommendation
        msg: `Controller is in Initialization mode - switch to Normal mode for operation`
      });
    }
    if (reg.CTRL.fields.MON === 1) {
      reg.CTRL.report.push({
        severityLevel: sevC.Info, // info
        msg: `Bus Monitoring Mode is active - controller will not transmit`
      });
    }
  }

  // === FIMC: Fault Injection Module Control Register ===================
  if ('FIMC' in reg && reg.FIMC.int32 !== undefined) {
    const regValue = reg.FIMC.int32;

    // 0. Extend existing register structure
    reg.FIMC.fields = {};
    reg.FIMC.report = []; // Initialize report array

    // 1. Decode all individual bits of FIMC register
    reg.FIMC.fields.FIME = getBits(regValue, 31, 31); // Fault Injection Module Enable
    reg.FIMC.fields.FIMS = getBits(regValue, 30, 29); // Fault Injection Module Select
    reg.FIMC.fields.FIMF = getBits(regValue, 28, 24); // Fault Injection Module Function
    reg.FIMC.fields.FIMP = getBits(regValue, 23, 16); // Fault Injection Module Parameter
    reg.FIMC.fields.FIMV = getBits(regValue, 15, 0);  // Fault Injection Module Value

    // 2. Generate human-readable register report
    reg.FIMC.report.push({
      severityLevel: sevC.Info, // info
      msg: `FIMC: ${reg.FIMC.name_long} (0x${regValue.toString(16).toUpperCase().padStart(8, '0')})\n` +
           `[FIME] Fault Injection Enable        = ${reg.FIMC.fields.FIME}\n` +
           `[FIMS] Fault Injection Module Select = ${reg.FIMC.fields.FIMS}\n` +
           `[FIMF] Fault Injection Function      = ${reg.FIMC.fields.FIMF}\n` +
           `[FIMP] Fault Injection Parameter     = ${reg.FIMC.fields.FIMP}\n` +
           `[FIMV] Fault Injection Value         = ${reg.FIMC.fields.FIMV}`
    });

    // 3. Add fault injection warnings
    if (reg.FIMC.fields.FIME === 1) {
      reg.FIMC.report.push({
        severityLevel: sevC.Warn, // warning
        msg: `Fault Injection Module is enabled - this should only be used for testing`
      });
    }
  }

}